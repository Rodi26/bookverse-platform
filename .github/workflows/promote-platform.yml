name: Promote

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Platform application version (SemVer). If empty, use latest."
        required: false
        type: string
      target_stage:
        description: 'Target stage (DEV, QA, STAGING)'
        required: true
        type: choice
        default: 'STAGING'
        options: [ DEV, QA, STAGING ]

jobs:
  promote:
    name: Promote
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: "[Auth] Persist JF access token (OIDC → JFrog)"
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          PROJECT: ${{ vars.PROJECT_KEY }}
          PROVIDER_NAME: bookverse-platform-github
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "❌ Missing GitHub OIDC request env vars" >&2; exit 1; fi
          GH_ID_TOKEN=$(curl -sS -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$GH_ID_TOKEN" || "$GH_ID_TOKEN" == "null" ]]; then echo "❌ Failed to fetch GitHub ID token" >&2; exit 1; fi
          PAYLOAD=$(jq -n --arg jwt "$GH_ID_TOKEN" \
            --arg provider_name "$PROVIDER_NAME" \
            --arg project_key "$PROJECT" \
            --arg job_id "${{ github.job }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg repo "https://github.com/${{ github.repository }}" \
            --arg revision "${{ github.sha }}" \
            --arg branch "${{ github.ref_name }}" \
            '{
              grant_type:"urn:ietf:params:oauth:grant-type:token-exchange",
              subject_token_type:"urn:ietf:params:oauth:token-type:id_token",
              subject_token:$jwt,
              provider_name:$provider_name,
              project_key:$project_key,
              job_id:$job_id,
              run_id:$run_id,
              repo:$repo,
              revision:$revision,
              branch:$branch
            }')
          TOKEN=$(curl -sS -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$JF_URL/access/api/v1/oidc/token" | jq -r .access_token)
          if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then echo "❌ Failed to exchange OIDC token" >&2; exit 1; fi
          echo "JF_ACCESS_TOKEN=$TOKEN" >> $GITHUB_ENV

      - name: "[Promote] AppTrust"
        id: promote
        env:
          JFROG_URL: ${{ vars.JFROG_URL }}
          JFROG_ADMIN_TOKEN: ${{ env.JF_ACCESS_TOKEN }}
          PROJECT_KEY: ${{ vars.PROJECT_KEY }}
        run: |
          python - << 'PY'
          import os, sys, json, urllib.request
          from urllib.error import HTTPError, URLError
          # Base API and auth
          base = (os.environ.get("JFROG_URL", "").rstrip('/') + "/apptrust/api/v1").rstrip('/')
          token = os.environ.get("JFROG_ADMIN_TOKEN", "")
          app = "bookverse-platform"
          # Resolve inputs
          input_version = os.environ.get("INPUT_VERSION", "${{ github.event.inputs.version }}").strip()
          target_display = os.environ.get("INPUT_TARGET_STAGE", "${{ github.event.inputs.target_stage }}").strip().upper()
          allowed_display = {"DEV", "QA", "STAGING"}
          if target_display not in allowed_display:
            print(f"Target stage must be one of {sorted(allowed_display)}", file=sys.stderr)
            sys.exit(2)
          # Map display -> API stage (prefix with project key for non‑PROD)
          project_key = (os.environ.get("PROJECT_KEY", "") or "").strip()
          api_stage = f"{project_key}-{target_display}" if project_key else target_display
          # Enforce platform visibility policy: platform uses public repos in nonprod
          # (Release workflow will handle public release repos)
          # Determine version if not provided: latest by created desc
          version = input_version
          if not version:
            url = f"{base}/applications/{app}/versions?limit=1&order_by=created&order_asc=false"
            req = urllib.request.Request(url=url, headers={"Authorization": f"Bearer {token}", "Accept": "application/json"})
            try:
              with urllib.request.urlopen(req, timeout=30) as resp:
                data = json.loads(resp.read().decode("utf-8")) or {}
                version = str((data.get("versions") or [{}])[0].get("version") or "").strip()
            except Exception as e:
              print(f"Failed to resolve latest version: {e}", file=sys.stderr)
              sys.exit(1)
            if not version:
              print("Could not determine latest platform version", file=sys.stderr)
              sys.exit(1)
          # Export resolved version and current stage before promotion
          try:
            req = urllib.request.Request(url=f"{base}/applications/{app}/versions/{version}/content", headers={"Authorization": f"Bearer {token}", "Accept": "application/json"})
            with urllib.request.urlopen(req, timeout=30) as resp:
              content = json.loads(resp.read().decode("utf-8")) or {}
              current_stage = str(content.get("current_stage") or "")
          except Exception:
            current_stage = ""
          geh = os.environ.get("GITHUB_ENV")
          if geh:
            with open(geh, "a", encoding="utf-8") as f:
              f.write(f"RESOLVED_VERSION={version}\n")
              if current_stage:
                f.write(f"CURRENT_STAGE_BEFORE={current_stage}\n")
              f.write(f"TARGET_DISPLAY={target_display}\n")
          # Perform promotion (nonprod promotion has no repos to include)
          body = json.dumps({"target_stage": api_stage}).encode('utf-8')
          req = urllib.request.Request(
            url=f"{base}/applications/{app}/versions/{version}/promote",
            data=body,
            headers={"Authorization": f"Bearer {token}", "Content-Type": "application/json"},
            method="POST",
          )
          try:
            with urllib.request.urlopen(req, timeout=30) as resp:
              print(resp.read().decode('utf-8'))
          except HTTPError as e:
            print(e.read().decode('utf-8', errors='replace'), file=sys.stderr)
            raise
          PY

      - name: "[Tags] Enforce PROD 'latest' invariants (if promoted to PROD)"
        run: |
          set -euo pipefail
          # Only run this if we would be promoting to PROD (though promote workflow targets non-PROD)
          if [[ "${TARGET_DISPLAY:-}" != "PROD" ]]; then
            echo "ℹ️ Skipping PROD latest tag enforcement (target is ${TARGET_DISPLAY:-unknown})"
            exit 0
          fi
          
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          APP_KEY="bookverse-platform"
          BASE="${{ vars.JFROG_URL }}/apptrust/api/v1"
          TOKEN="$JF_ACCESS_TOKEN"
          RESP=$(mktemp)
          code=$(curl -sS -L -o "$RESP" -w "%{http_code}" \
            "$BASE/applications/$APP_KEY/versions?limit=1000&order_by=created&order_asc=false" \
            -H "Authorization: Bearer $TOKEN" -H "Accept: application/json" || echo 000)
          if [[ "$code" -lt 200 || "$code" -ge 300 ]]; then
            echo "❌ Failed to list versions (HTTP $code)" >&2; cat "$RESP" || true; exit 1
          fi
          DESIRED=$(jq -r '[.versions[] | select((.release_status|tostring|ascii_upcase)=="RELEASED" or (.release_status|tostring|ascii_upcase)=="TRUSTED_RELEASE") | .version] | unique | map(select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))) | sort_by(split(".")|map(tonumber)) | last // empty' "$RESP")
          if [[ -z "$DESIRED" ]]; then
            mapfile -t PREV_LATEST < <(jq -r '.versions[] | select(.tag=="latest") | .version' "$RESP")
            for pv in "${PREV_LATEST[@]:-}"; do
              [ -z "$pv" ] && continue
              restore=$(jq -r --arg v "$pv" '.versions[] | select(.version==$v) | (.properties.original_tag_before_latest[0] // .version // "")' "$RESP")
              printf '{"tag":"%s","delete_properties":["original_tag_before_latest"]}' "$restore" > body.json
              curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$pv" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
            done
            rm -f "$RESP" body.json
            exit 0
          fi
          CURR_TAG=$(jq -r --arg v "$DESIRED" '.versions[] | select(.version==$v) | (.tag // "")' "$RESP")
          jq -n --arg ct "$CURR_TAG" '{tag:"latest", properties:{original_tag_before_latest:[$ct]}}' > body.json
          curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$DESIRED" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
          mapfile -t OTHERS < <(jq -r --arg v "$DESIRED" '.versions[] | select(.tag=="latest" and .version!=$v) | .version' "$RESP")
          for ov in "${OTHERS[@]:-}"; do
            [ -z "$ov" ] && continue
            restore=$(jq -r --arg v "$ov" '.versions[] | select(.version==$v) | (.properties.original_tag_before_latest[0] // .version // "")' "$RESP")
            printf '{"tag":"%s","delete_properties":["original_tag_before_latest"]}' "$restore" > body.json
            curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$ov" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
          done
          rm -f "$RESP" body.json || true

      - name: "[Summary] Promotion"
        if: always()
        run: |
          set -euo pipefail
          PROJECT_KEY='${{ vars.PROJECT_KEY }}'
          CURRENT_DISPLAY="${CURRENT_STAGE_BEFORE:-UNASSIGNED}"
          # Normalize display: strip project prefix when present
          if [[ -n "$PROJECT_KEY" && "$CURRENT_DISPLAY" == "$PROJECT_KEY-"* ]]; then
            CURRENT_DISPLAY="${CURRENT_DISPLAY#${PROJECT_KEY}-}"
          fi
          CURRENT_DISPLAY="${CURRENT_DISPLAY#bookverse-}"
          TARGET_DISPLAY="${TARGET_DISPLAY:-${{ inputs.target_stage }}}"
          export CURRENT_DISPLAY TARGET_DISPLAY
          STAGES="DEV QA STAGING PROD"
          IFS=' ' read -r -a STAGE_ARR <<< "$STAGES"
          idx_current=-1; idx_target=-1
          for i in "${!STAGE_ARR[@]}"; do
            if [[ "${STAGE_ARR[$i]}" == "$CURRENT_DISPLAY" ]]; then idx_current=$i; fi
            if [[ "${STAGE_ARR[$i]}" == "$TARGET_DISPLAY" ]]; then idx_target=$i; fi
          done
          pre=""; post=""; sep=""
          if [[ $idx_current -ge 0 && $idx_target -ge 0 ]]; then
            for ((j=0;j<idx_current;j++)); do
              if [[ -n "$pre" ]]; then sep=" → "; else sep=""; fi
              pre+="$sep${STAGE_ARR[$j]}"
            done
            for ((j=idx_target+1;j<${#STAGE_ARR[@]};j++)); do
              if [[ -n "$post" ]]; then sep=" → "; else sep=""; fi
              post+="$sep${STAGE_ARR[$j]}"
            done
            LC_PATH="${pre:+$pre → }**${CURRENT_DISPLAY} ➔ ${TARGET_DISPLAY}**${post:+ → $post}"
          else
            LC_PATH="$STAGES"
          fi
          OUTCOME="SUCCESS"
          echo "### Executive Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Lifecycle:** UNASSIGNED → DEV → QA → STAGING → PROD" >> $GITHUB_STEP_SUMMARY
          echo "- **Application:** bookverse-platform" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${RESOLVED_VERSION:-${{ inputs.version }}}" >> $GITHUB_STEP_SUMMARY
          echo "- **From → To:** ${CURRENT_DISPLAY} → ${TARGET_DISPLAY}" >> $GITHUB_STEP_SUMMARY
          echo "- **Outcome:** ✅ ${OUTCOME}" >> $GITHUB_STEP_SUMMARY

