name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Platform application version (SemVer). Default: latest in STAGING"
        required: false
        type: string

jobs:
  release:
    name: Release from STAGING to PROD
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: "[Auth] Persist JF access token (OIDC → JFrog)"
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          PROJECT: ${{ vars.PROJECT_KEY }}
          PROVIDER_NAME: bookverse-platform-github
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "❌ Missing GitHub OIDC request env vars" >&2; exit 1; fi
          GH_ID_TOKEN=$(curl -sS -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$GH_ID_TOKEN" || "$GH_ID_TOKEN" == "null" ]]; then echo "❌ Failed to fetch GitHub ID token" >&2; exit 1; fi
          PAYLOAD=$(jq -n --arg jwt "$GH_ID_TOKEN" \
            --arg provider_name "$PROVIDER_NAME" \
            --arg project_key "$PROJECT" \
            --arg job_id "${{ github.job }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg repo "https://github.com/${{ github.repository }}" \
            --arg revision "${{ github.sha }}" \
            --arg branch "${{ github.ref_name }}" \
            '{
              grant_type:"urn:ietf:params:oauth:grant-type:token-exchange",
              subject_token_type:"urn:ietf:params:oauth:token-type:id_token",
              subject_token:$jwt,
              provider_name:$provider_name,
              project_key:$project_key,
              job_id:$job_id,
              run_id:$run_id,
              repo:$repo,
              revision:$revision,
              branch:$branch
            }')
          TOKEN=$(curl -sS -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$JF_URL/access/api/v1/oidc/token" | jq -r .access_token)
          if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then echo "❌ Failed to exchange OIDC token" >&2; exit 1; fi
          echo "JF_OIDC_TOKEN=$TOKEN" >> $GITHUB_ENV

      - name: "[Resolve] Version (latest in STAGING if empty)"
        id: resolve
        env:
          JFROG_URL: ${{ vars.JFROG_URL }}
          JF_OIDC_TOKEN: ${{ env.JF_OIDC_TOKEN }}
          PROJECT_KEY: ${{ vars.PROJECT_KEY }}
        run: |
          python - << 'PY'
          import os, json, urllib.request, urllib.parse
          from urllib.error import HTTPError
          base = (os.environ.get("JFROG_URL", "").rstrip('/') + "/apptrust/api/v1").rstrip('/')
          token = os.environ.get("JF_OIDC_TOKEN", "")
          project_key = os.environ.get("PROJECT_KEY", "bookverse")
          app = "bookverse-platform"
          version = "${{ github.event.inputs.version }}".strip()
          print(f"Debug: AppTrust base URL: {base}")
          print(f"Debug: Application: {app}")
          print(f"Debug: Project: {project_key}")
          print(f"Debug: Token available: {'Yes' if token else 'No'}")
          def list_versions():
            url = f"{base}/applications/{urllib.parse.quote(app)}/versions?limit=50&order_by=created&order_asc=false"
            print(f"Debug: Calling list_versions URL: {url}")
            try:
              req = urllib.request.Request(url=url, headers={"Authorization": f"Bearer {token}", "Accept": "application/json"})
              with urllib.request.urlopen(req, timeout=30) as resp:
                return json.loads(resp.read().decode("utf-8")) or {}
            except HTTPError as e:
              print(f"HTTP Error in list_versions: {e.code} {e.reason}")
              print(f"Response body: {e.read().decode('utf-8') if hasattr(e, 'read') else 'N/A'}")
              raise
          def get_content(ver:str):
            url = f"{base}/applications/{urllib.parse.quote(app)}/versions/{urllib.parse.quote(ver)}/content"
            print(f"Debug: Calling get_content URL: {url}")
            try:
              req = urllib.request.Request(url=url, headers={"Authorization": f"Bearer {token}", "Accept": "application/json"})
              with urllib.request.urlopen(req, timeout=30) as resp:
                return json.loads(resp.read().decode("utf-8")) or {}
            except HTTPError as e:
              print(f"HTTP Error in get_content: {e.code} {e.reason}")
              print(f"Response body: {e.read().decode('utf-8') if hasattr(e, 'read') else 'N/A'}")
              raise
          if not version:
            try:
              data = list_versions(); vers = data.get("versions", [])
            except HTTPError as e:
              if e.code == 404:
                print(f"Application '{app}' not found. Attempting to create it...")
                create_app_payload = {
                  "application_name": "BookVerse Platform",
                  "application_key": app,
                  "project_key": project_key,
                  "description": "Integrated platform solution combining all microservices",
                  "criticality": "high"
                }
                print(f"Debug: Creating application with payload: {json.dumps(create_app_payload, indent=2)}")
                create_req = urllib.request.Request(
                  url=f"{base}/applications",
                  data=json.dumps(create_app_payload).encode('utf-8'),
                  headers={
                    "Authorization": f"Bearer {token}", 
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "X-JFrog-Project": project_key
                  }
                )
                try:
                  with urllib.request.urlopen(create_req, timeout=30) as resp:
                    print(f"Application created successfully: {resp.read().decode('utf-8')}")
                    data = list_versions(); vers = data.get("versions", [])
                except Exception as create_err:
                  print(f"Failed to create application: {create_err}")
                  raise SystemExit("Could not create or access platform application")
              else:
                raise
            chosen = ""
            for v in vers:
              ver = str(v.get("version") or "").strip()
              if not ver:
                continue
              try:
                content = get_content(ver)
              except Exception:
                continue
              cs = str(content.get("current_stage") or "")
              if cs.endswith("STAGING"):
                chosen = ver
                break
            if not chosen:
              chosen = str((vers[0] or {}).get("version") or "") if vers else ""
            version = chosen
          if not version:
            print("⚠️ No platform version found in STAGING.")
            print("💡 Platform versions are created by the aggregate workflow.")
            print("🔧 To create platform versions:")
            print("   1. Run the 'Aggregate' workflow first")
            print("   2. Promote a version to STAGING") 
            print("   3. Then run this release workflow")
            raise SystemExit("Could not determine platform version (no STAGING version found)")
          geh = os.environ.get("GITHUB_ENV")
          if geh:
            with open(geh, 'a', encoding='utf-8') as f:
              f.write(f"RESOLVED_VERSION={version}\n")
          gout = os.environ.get("GITHUB_OUTPUT")
          if gout:
            with open(gout, 'a', encoding='utf-8') as f:
              f.write(f"version={version}\n")
          print(f"Resolved version: {version}")
          PY

      - name: "[Release] AppTrust"
        env:
          JFROG_URL: ${{ vars.JFROG_URL }}
          JF_OIDC_TOKEN: ${{ env.JF_OIDC_TOKEN }}
          PROJECT_KEY: ${{ vars.PROJECT_KEY }}
        run: |
          python - << 'PY'
          import os, json, urllib.request
          base = (os.environ.get("JFROG_URL", "").rstrip('/') + "/apptrust/api/v1").rstrip('/')
          token = os.environ.get("JF_OIDC_TOKEN", "")
          app = "bookverse-platform"
          version = "${{ steps.resolve.outputs.version }}".strip() or os.environ.get("RESOLVED_VERSION", "${{ github.event.inputs.version }}").strip()
          jf_url = os.environ.get("JFROG_URL", "").rstrip('/')
          project = os.environ.get("PROJECT_KEY", "bookverse").strip()
          candidates = [
            f"{project}-platform-public-docker-release-local",
            f"{project}-platform-public-python-release-local",
            f"{project}-platform-public-maven-release-local",
            f"{project}-platform-public-generic-release-local",
          ]
          included = []
          for key in candidates:
            try:
              req = urllib.request.Request(
                url=f"{jf_url}/artifactory/api/repositories/{key}",
                headers={"Authorization": f"Bearer {token}", "Accept": "application/json", "X-JFrog-Project": project},
              )
              with urllib.request.urlopen(req, timeout=20) as resp:
                if 200 <= resp.status < 300:
                  included.append(key)
            except Exception:
              pass
          if not included:
            included = [
              f"{project}-platform-public-docker-release-local",
              f"{project}-platform-public-python-release-local",
            ]
          body = json.dumps({"promotion_type": "move", "included_repository_keys": included}).encode('utf-8')
          req = urllib.request.Request(
            url=f"{base}/applications/{app}/versions/{version}/release",
            data=body,
            headers={"Authorization": f"Bearer {token}", "Content-Type": "application/json"},
            method="POST",
          )
          with urllib.request.urlopen(req, timeout=30) as resp:
            print(resp.read().decode('utf-8'))
          PY

      - name: "[Tags] Enforce PROD 'latest' invariants"
        env:
          JFROG_URL: ${{ vars.JFROG_URL }}
          JF_OIDC_TOKEN: ${{ env.JF_OIDC_TOKEN }}
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          APP_KEY="bookverse-platform"
          BASE="${JFROG_URL%/}/apptrust/api/v1"
          TOKEN="$JF_OIDC_TOKEN"
          RESP=$(mktemp)
          code=$(curl -sS -L -o "$RESP" -w "%{http_code}" \
            "$BASE/applications/$APP_KEY/versions?limit=1000&order_by=created&order_asc=false" \
            -H "Authorization: Bearer $TOKEN" -H "Accept: application/json" || echo 000)
          if [[ "$code" -lt 200 || "$code" -ge 300 ]]; then
            echo "❌ Failed to list versions (HTTP $code)" >&2; cat "$RESP" || true; exit 1
          fi
          DESIRED=$(jq -r '[.versions[] | select((.release_status|tostring|ascii_upcase)=="RELEASED" or (.release_status|tostring|ascii_upcase)=="TRUSTED_RELEASE") | .version] | unique | map(select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))) | sort_by(split(".")|map(tonumber)) | last // empty' "$RESP")
          if [[ -z "$DESIRED" ]]; then
            mapfile -t PREV_LATEST < <(jq -r '.versions[] | select(.tag=="latest") | .version' "$RESP")
            for pv in "${PREV_LATEST[@]:-}"; do
              [ -z "$pv" ] && continue
              restore=$(jq -r --arg v "$pv" '.versions[] | select(.version==$v) | (.properties.original_tag_before_latest[0] // .version // "")' "$RESP")
              printf '{"tag":"%s","delete_properties":["original_tag_before_latest"]}' "$restore" > body.json
              curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$pv" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
            done
            rm -f "$RESP" body.json
            exit 0
          fi
          CURR_TAG=$(jq -r --arg v "$DESIRED" '.versions[] | select(.version==$v) | (.tag // "")' "$RESP")
          jq -n --arg ct "$CURR_TAG" '{tag:"latest", properties:{original_tag_before_latest:[$ct]}}' > body.json
          curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$DESIRED" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
          mapfile -t OTHERS < <(jq -r --arg v "$DESIRED" '.versions[] | select(.tag=="latest" and .version!=$v) | .version' "$RESP")
          for ov in "${OTHERS[@]:-}"; do
            [ -z "$ov" ] && continue
            restore=$(jq -r --arg v "$ov" '.versions[] | select(.version==$v) | (.properties.original_tag_before_latest[0] // .version // "")' "$RESP")
            printf '{"tag":"%s","delete_properties":["original_tag_before_latest"]}' "$restore" > body.json
            curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$ov" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
          done
          rm -f "$RESP" body.json || true

      - name: "[Helm] Pin version"
        if: ${{ false }}
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository_owner }}/bookverse-helm
          event-type: platform_release
          client-payload: '{"platform_version": "${{ steps.resolve.outputs.version }}"}'

      - name: "[Helm] Skipping repo dispatch (handled by webhook)"
        run: |
          echo "Repository dispatch is disabled in this workflow."
          echo "A webhook will trigger the platform-webhook adapter, which will dispatch 'platform_release'/'platform_release_completed' to bookverse-helm."
          echo "Resolved version: ${{ steps.resolve.outputs.version }}"

      - name: "[Summary] Release"
        run: |
          echo "### Platform Release" >> $GITHUB_STEP_SUMMARY
          echo "- **Application:** bookverse-platform" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${{ steps.resolve.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **From → To:** STAGING → PROD" >> $GITHUB_STEP_SUMMARY


