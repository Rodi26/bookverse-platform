# AppTrust rollback for platform version
name: Rollback

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Version to rollback (SemVer). Omit to use latest promoted"
        required: false
        type: string
      dry_run:
        description: "Dry run (no mutations)"
        required: false
        default: false
        type: boolean

jobs:
  rollback:
    name: Rollback
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      id-token: write
    env:
      JFROG_URL: ${{ vars.JFROG_URL }}
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Auth] Persist JF access token (OIDC → JFrog)"
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          PROJECT: ${{ vars.PROJECT_KEY }}
          PROVIDER_NAME: bookverse-platform-github
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          if [[ -z "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}" ]]; then
            echo "❌ Missing GitHub OIDC request env vars" >&2; exit 1; fi
          GH_ID_TOKEN=$(curl -sS -H "Authorization: Bearer ${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=${JF_URL}" | jq -r .value)
          if [[ -z "$GH_ID_TOKEN" || "$GH_ID_TOKEN" == "null" ]]; then echo "❌ Failed to fetch GitHub ID token" >&2; exit 1; fi
          PAYLOAD=$(jq -n --arg jwt "$GH_ID_TOKEN" \
            --arg provider_name "$PROVIDER_NAME" \
            --arg project_key "$PROJECT" \
            --arg job_id "${{ github.job }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg repo "https://github.com/${{ github.repository }}" \
            --arg revision "${{ github.sha }}" \
            --arg branch "${{ github.ref_name }}" \
            '{
              grant_type:"urn:ietf:params:oauth:grant-type:token-exchange",
              subject_token_type:"urn:ietf:params:oauth:token-type:id_token",
              subject_token:$jwt,
              provider_name:$provider_name,
              project_key:$project_key,
              job_id:$job_id,
              run_id:$run_id,
              repo:$repo,
              revision:$revision,
              branch:$branch
            }')
          TOKEN=$(curl -sS -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "$JF_URL/access/api/v1/oidc/token" | jq -r .access_token)
          if [[ -z "$TOKEN" || "$TOKEN" == "null" ]]; then echo "❌ Failed to exchange OIDC token" >&2; exit 1; fi
          echo "JF_OIDC_TOKEN=$TOKEN" >> $GITHUB_ENV

      - name: "[Setup] AppTrust context"
        run: |
          BASE="${JFROG_URL%/}"
          echo "APPTRUST_BASE_URL=${BASE}/apptrust/api/v1" >> "$GITHUB_ENV"
          echo "APPTRUST_ACCESS_TOKEN=${JF_OIDC_TOKEN}" >> "$GITHUB_ENV"

      - name: "[Setup] Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Setup JFrog CLI
        # uses: jfrog/setup-jfrog-cli@v4
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest
          oidc-provider-name: bookverse-platform-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: true
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}

      - name: "[Configure] JFrog server (OIDC)"
        run: |
          jf c add --interactive=false --url "${{ vars.JFROG_URL }}" --access-token "$JF_OIDC_TOKEN"

      - name: "[Preflight] Validate environment"
        run: |
          which jf
          jf -v || true
          python -V
          ls -la
          test -f scripts/apptrust_rollback.py
          echo "OK: preflight"

      - name: "[Resolve] Target version"
        shell: bash
        run: |
          set -euo pipefail
          TARGET_VERSION="${{ github.event.inputs.version }}"
          if [ -z "${TARGET_VERSION}" ]; then
            APP_KEY="bookverse-platform"
            RESP_FILE=$(mktemp)
            HTTP_STATUS=$(curl -sS -o "$RESP_FILE" -w "%{http_code}" \
              "$APPTRUST_BASE_URL/applications/$APP_KEY/versions?limit=20&order_by=created&order_asc=false" \
              -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" \
              -H "Accept: application/json")
            if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
              # First try to find RELEASED or TRUSTED_RELEASE versions (preferred)
              TARGET_VERSION=$(jq -r '.versions[] | select((.release_status|tostring|ascii_upcase)=="RELEASED" or (.release_status|tostring|ascii_upcase)=="TRUSTED_RELEASE") | .version' "$RESP_FILE" | head -n1)
              
              # If no RELEASED/TRUSTED_RELEASE versions found, try PRE_RELEASE as fallback
              if [ -z "${TARGET_VERSION:-}" ] || [ "$TARGET_VERSION" = "null" ]; then
                echo "ℹ️ No RELEASED/TRUSTED_RELEASE versions found, using latest PRE_RELEASE version"
                TARGET_VERSION=$(jq -r '.versions[] | select((.release_status|tostring|ascii_upcase)=="PRE_RELEASE") | .version' "$RESP_FILE" | head -n1)
              fi
            fi
            rm -f "$RESP_FILE"
            if [ -z "${TARGET_VERSION:-}" ] || [ "$TARGET_VERSION" = "null" ]; then
              echo "Could not resolve latest promoted version for $APP_KEY" >&2
              exit 1
            fi
            echo "Resolved target version: $TARGET_VERSION"
          fi
          echo "TARGET_VERSION=$TARGET_VERSION" >> $GITHUB_ENV

      - name: "[Dry Run] Validate only"
        if: ${{ inputs.dry_run == true }}
        run: |
          echo "DRY RUN: Would invoke rollback for version ${TARGET_VERSION}"

      - name: "[Rollback] Execute"
        if: ${{ inputs.dry_run != true }}
        shell: bash
        run: |
          set -euo pipefail
          echo "🧭 Starting rollback workflow"
          APP_KEY="bookverse-platform"

          # Snapshot BEFORE stage via content API
          CONTENT_BEFORE=$(mktemp)
          CODE_B=$(curl -sS -L -o "$CONTENT_BEFORE" -w "%{http_code}" \
            -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" -H "Accept: application/json" \
            "$APPTRUST_BASE_URL/applications/$APP_KEY/versions/$TARGET_VERSION/content" || echo 000)
          CURRENT_STAGE_BEFORE=""
          if [[ "$CODE_B" -ge 200 && "$CODE_B" -lt 300 ]]; then
            CURRENT_STAGE_BEFORE=$(jq -r '.current_stage // empty' "$CONTENT_BEFORE" 2>/dev/null || echo "")
          fi
          rm -f "$CONTENT_BEFORE"
          echo "📍 Stage BEFORE: ${CURRENT_STAGE_BEFORE:-unknown}"
          echo "CURRENT_STAGE_BEFORE=${CURRENT_STAGE_BEFORE:-}" >> $GITHUB_ENV

          STATUS="SUCCESS"
          MSG=""
          echo "🔁 Executing rollback via AppTrust rollback API"
          # Call JFrog AppTrust rollback API to perform stage rollback
          from_stage="PROD"  # Always rollback from PROD for safety
          echo "Calling AppTrust endpoint: POST /applications/$APP_KEY/versions/$TARGET_VERSION/rollback with body {from_stage: $from_stage}"
          if curl -sS -L -X POST \
            "$APPTRUST_BASE_URL/applications/$APP_KEY/versions/$TARGET_VERSION/rollback" \
            -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" \
            -H "Content-Type: application/json" \
            -H "Accept: application/json" \
            -d "{\"from_stage\": \"$from_stage\"}" --fail; then
            MSG="Rollback executed for $APP_KEY@$TARGET_VERSION from $from_stage"
            echo "✅ $MSG"
          else
            STATUS="FAILED"
            MSG="Rollback failed for $APP_KEY@$TARGET_VERSION"
            echo "❌ $MSG"
          fi

          # Fetch AFTER stage via content API
          CONTENT_TARGET=$(mktemp)
          CODE_T=$(curl -sS -L -o "$CONTENT_TARGET" -w "%{http_code}" \
            -H "Authorization: Bearer $APPTRUST_ACCESS_TOKEN" -H "Accept: application/json" \
            "$APPTRUST_BASE_URL/applications/$APP_KEY/versions/$TARGET_VERSION/content" || echo 000)
          CURR_STAGE_TARGET=""
          if [[ "$CODE_T" -ge 200 && "$CODE_T" -lt 300 ]]; then
            CURR_STAGE_TARGET=$(jq -r '.current_stage // empty' "$CONTENT_TARGET" 2>/dev/null || echo "")
          fi
          rm -f "$CONTENT_TARGET"
          echo "📍 Stage AFTER:  ${CURR_STAGE_TARGET:-unknown}"
          echo "CURR_STAGE_TARGET=${CURR_STAGE_TARGET:-}" >> $GITHUB_ENV

      - name: "[Tags] Mark rolled back version as Quarantine"
        if: ${{ inputs.dry_run != true }}
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          APP_KEY="bookverse-platform"
          BASE="${{ vars.JFROG_URL }}/apptrust/api/v1"
          TOKEN="$JF_OIDC_TOKEN"
          ROLLBACK_VERSION="$TARGET_VERSION"
          
          # Generate quarantine tag with timestamp
          QUARANTINE_TAG="Quarantine-$(date -u +%Y%m%d-%H%M%S)"
          echo "🚨 Marking rolled back version $ROLLBACK_VERSION with quarantine tag: $QUARANTINE_TAG"
          
          # Set quarantine tag for the rolled back version  
          jq -n --arg tag "$QUARANTINE_TAG" '{tag: $tag, delete_properties: ["original_tag_before_latest"]}' > quarantine_body.json
          curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$ROLLBACK_VERSION" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d @quarantine_body.json | cat
          rm -f quarantine_body.json || true
          echo "✅ Quarantine tag set for rolled back version $ROLLBACK_VERSION"

      - name: "[Tags] Enforce PROD 'latest' invariants"
        if: ${{ inputs.dry_run != true }}
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          APP_KEY="bookverse-platform"
          BASE="${{ vars.JFROG_URL }}/apptrust/api/v1"
          TOKEN="$JF_OIDC_TOKEN"
          RESP=$(mktemp)
          code=$(curl -sS -L -o "$RESP" -w "%{http_code}" \
            "$BASE/applications/$APP_KEY/versions?limit=1000&order_by=created&order_asc=false" \
            -H "Authorization: Bearer $TOKEN" -H "Accept: application/json" || echo 000)
          if [[ "$code" -lt 200 || "$code" -ge 300 ]]; then
            echo "❌ Failed to list versions (HTTP $code)" >&2; cat "$RESP" || true; exit 1
          fi
          DESIRED=$(jq -r '[.versions[] | select((.release_status|tostring|ascii_upcase)=="RELEASED" or (.release_status|tostring|ascii_upcase)=="TRUSTED_RELEASE") | .version] | unique | map(select(test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))) | sort_by(split(".")|map(tonumber)) | last // empty' "$RESP")
          if [[ -n "$DESIRED" ]]; then
            CURR_TAG=$(jq -r --arg v "$DESIRED" '.versions[] | select(.version==$v) | (.tag // "")' "$RESP")
            jq -n --arg ct "$CURR_TAG" '{tag:"latest", properties:{original_tag_before_latest:[$ct]}}' > body.json
            curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$DESIRED" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
          fi
          mapfile -t OTHERS < <(jq -r --arg v "$DESIRED" '.versions[] | select(.tag=="latest" and .version!=$v) | .version' "$RESP")
          for ov in "${OTHERS[@]:-}"; do
            [ -z "$ov" ] && continue
            restore=$(jq -r --arg v "$ov" '.versions[] | select(.version==$v) | (.properties.original_tag_before_latest[0] // .version // "")' "$RESP")
            printf '{"tag":"%s","delete_properties":["original_tag_before_latest"]}' "$restore" > body.json
            curl -sS -L -X PATCH "$BASE/applications/$APP_KEY/versions/$ov" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d @body.json | cat
          done
          rm -f "$RESP" body.json || true

      - name: "[Validation] Check rollback success"
        if: ${{ inputs.dry_run != true }}
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y jq; fi
          
          # Determine lifecycle stages to compute expected previous stage
          PROJECT_KEY_ENV="${{ vars.PROJECT_KEY }}"
          LC_FILE=$(mktemp)
          PLATFORM_URL="${{ vars.JFROG_URL }}"
          CODE_LC=$(curl -sS -L -o "$LC_FILE" -w "%{http_code}" \
            -H "Authorization: Bearer $JF_OIDC_TOKEN" -H "Accept: application/json" \
            "$PLATFORM_URL/access/api/v2/lifecycle/?project_key=$PROJECT_KEY_ENV" || echo 000)
          NORM_FILE=$(mktemp)
          if [[ "$CODE_LC" -ge 200 && "$CODE_LC" -lt 300 ]]; then
            jq -c 'if type=="array" then . elif has("lifecycles") then .lifecycles elif has("items") then .items elif has("results") then .results elif (has("name") and has("stages")) then [.] else [] end' "$LC_FILE" > "$NORM_FILE" 2>/dev/null || printf '[]' > "$NORM_FILE"
          else
            printf '[]' > "$NORM_FILE"
          fi
          rm -f "$LC_FILE"
          LIFECYCLE_NAME="bookverse-lifecycle"
          STAGES=()
          while IFS= read -r s; do
            [ -z "$s" ] && continue
            s_disp="$s"
            case "$s_disp" in
              "$PROJECT_KEY_ENV"-*) s_disp="${s_disp#${PROJECT_KEY_ENV}-}";;
            esac
            STAGES+=("$s_disp")
          done < <(jq -r --arg n "$LIFECYCLE_NAME" '([ .[] | select(.name==$n) | .stages ] | .[0] // []) | map(if type=="object" then .name else . end) | .[]' "$NORM_FILE" 2>/dev/null)
          rm -f "$NORM_FILE"
          if [[ ${#STAGES[@]} -eq 0 ]]; then
            STAGES=(DEV QA STAGING PROD)
          fi
          echo "🧭 Lifecycle stages: ${STAGES[*]}"
          
          # Compute expected previous stage
          display_stage() {
            local x="$1"; local p="$PROJECT_KEY_ENV"; if [[ "$x" == "PROD" || "$x" == "$p-PROD" ]]; then echo "PROD"; elif [[ "$x" == "$p-"* ]]; then echo "${x#${p}-}"; else echo "$x"; fi
          }
          CURR_BEFORE_DISP=$(display_stage "${CURRENT_STAGE_BEFORE}")
          CURR_AFTER_DISP=$(display_stage "${CURR_STAGE_TARGET}")
          idx_before=-1
          for i in "${!STAGES[@]}"; do if [[ "${STAGES[$i]}" == "$CURR_BEFORE_DISP" ]]; then idx_before=$i; break; fi; done
          EXPECTED_PREV="UNASSIGNED"
          if [[ $idx_before -gt 0 ]]; then EXPECTED_PREV="${STAGES[$((idx_before-1))]}"; elif [[ $idx_before -eq 0 ]]; then EXPECTED_PREV="UNASSIGNED"; fi
          echo "🔎 Expected previous stage: ${EXPECTED_PREV}"

          VALIDATION_ERRORS=()
          if [[ -z "$CURRENT_STAGE_BEFORE" || "$CURR_BEFORE_DISP" == "UNASSIGNED" ]]; then
            VALIDATION_ERRORS+=("Cannot rollback UNASSIGNED version")
          fi
          if [[ "$CURR_AFTER_DISP" != "$EXPECTED_PREV" ]]; then
            VALIDATION_ERRORS+=("Stage after rollback '$CURR_AFTER_DISP' != expected '$EXPECTED_PREV'")
          fi

          # Finalize validation status after all checks
          STATUS="SUCCESS"
          MSG="Rollback executed for bookverse-platform@${TARGET_VERSION}"
          if [ ${#VALIDATION_ERRORS[@]} -gt 0 ]; then
            STATUS="FAILED"
            MSG="Validation failed: ${VALIDATION_ERRORS[*]}"
          fi

          {
            echo "## 🔄 Platform Rollback"
            echo ""
            echo "**Repository:** \`${{ github.repository }}\`"
            echo "**Application:** \`bookverse-platform\`"
            echo "**Target Version:** \`${TARGET_VERSION:-unknown}\`"
            echo "**Status:** ${STATUS}"
            echo ""
            echo "### Details"
            echo "- Triggered by: \`${{ github.actor }}\`"
            echo "- Workflow run: \`${{ github.run_id }}\` (attempt \`${{ github.run_attempt }}\`)"
            echo "- Timestamp (UTC): \`$(date -u +%Y-%m-%dT%H:%M:%SZ)\`"
            echo ""
            echo "### Validation"
            echo "- Stage before: \`${CURR_BEFORE_DISP:-unknown}\`"
            echo "- Stage after:  \`${CURR_AFTER_DISP:-unknown}\`"
            echo "- Expected previous stage: \`${EXPECTED_PREV:-unknown}\`"
            if [ "${#VALIDATION_ERRORS[@]}" -gt 0 ]; then
              echo "- Result: ❌ ${MSG}"
            else
              echo "- Result: ✅ Rollback validated"
            fi
            echo ""
            echo "${MSG}"
          } >> "$GITHUB_STEP_SUMMARY"

          # Fail the job if validation failed
          if [ "$STATUS" = "FAILED" ]; then
            echo "${MSG}" >&2
            exit 1
          fi


